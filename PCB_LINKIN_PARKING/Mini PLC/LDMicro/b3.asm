;/* This is auto-generated ASM code from LDmicro. Do not edit this file!
;   Go back to the LDmicro ladder diagram source for changes in the ladder logic. */
; PIC16F887 is the LDmicro target processor.
	LIST    p=PIC16F887
#include P16F887.inc
	__CONFIG 0x2007, 0x23E2
	__CONFIG 0x2008, 0x600
	radix dec
	org 0
;TABSIZE = 8
;	CODE
    ; Reset vector
i_000000: clrf	 0x03            	  ; (OP_CLRF, REG_STATUS)
i_000001: clrf	 0x0A            	  ; (OP_CLRF, REG_PCLATH)
          nop	 		 	  ; (OP_NOP_, 0, 0)
    ; GOTO progStart
i_000003: goto	 l_0000af	 	  ; (OP_GOTO, progStart)
    ; Interrupt Vector
i_000004: retfie	 	 	  ; (OP_RETFIE, 0, 0)
          nop	 		 	  ; (OP_NOP_, 0, 0)
          nop	 		 	  ; (OP_NOP_, 0, 0)
          nop	 		 	  ; (OP_NOP_, 0, 0)
    ; MultiplyRoutine16x16=32 (2x2=4)
l_000008: clrf	 0x27            	  ; (OP_CLRF, result3)
          clrf	 0x26            	  ; (OP_CLRF, result2)
          bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
          rrf	 0x25            , 1	  ; (OP_RRF, result1, DEST_F)
          rrf	 0x24            , 1	  ; (OP_RRF, result0, DEST_F)
          movlw	 0x10             	  ; (OP_MOVLW, 16)
          movwf	 0x2E            	  ; (OP_MOVWF, counter)
l_00000f: btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          goto	 l_000017	 	  ; (OP_GOTO, dontAdd)
          movf	 0x22            , 0 	  ; (OP_MOVF, multiplicand0, DEST_W)
          addwf	 0x26            , 1	  ; (OP_ADDWF, result2, DEST_F)
          btfsc	 0x03            , 0	  ; (OP_BTFSC, REG_STATUS, STATUS_C)
          incf	 0x27            , 1	  ; (OP_INCF, result3, DEST_F)
          movf	 0x23            , 0 	  ; (OP_MOVF, multiplicand1, DEST_W)
          addwf	 0x27            , 1	  ; (OP_ADDWF, result3, DEST_F)
l_000017: bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
          rrf	 0x27            , 1	  ; (OP_RRF, result3, DEST_F)
          rrf	 0x26            , 1	  ; (OP_RRF, result2, DEST_F)
          rrf	 0x25            , 1	  ; (OP_RRF, result1, DEST_F)
          rrf	 0x24            , 1	  ; (OP_RRF, result0, DEST_F)
          decfsz 0x2E            , 1	  ; (OP_DECFSZ, counter, DEST_F)
          goto	 l_00000f	 	  ; (OP_GOTO, top)
i_00001e: return	 	 	  ; (OP_RETURN)
    ; MultiplyRoutine24x16=40 (3x2=5)
          clrf	 0x28            	  ; (OP_CLRF, result4)
          clrf	 0x27            	  ; (OP_CLRF, result3)
          bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
          rrf	 0x26            , 1	  ; (OP_RRF, result2, DEST_F)
          rrf	 0x25            , 1	  ; (OP_RRF, result1, DEST_F)
          rrf	 0x24            , 1	  ; (OP_RRF, result0, DEST_F)
          movlw	 0x18             	  ; (OP_MOVLW, 24)
          movwf	 0x2E            	  ; (OP_MOVWF, counter)
l_000027: btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          goto	 l_00002f	 	  ; (OP_GOTO, dontAdd)
          movf	 0x22            , 0 	  ; (OP_MOVF, multiplicand0, DEST_W)
          addwf	 0x27            , 1	  ; (OP_ADDWF, result3, DEST_F)
          movf	 0x23            , 0 	  ; (OP_MOVF, multiplicand1, DEST_W)
          btfsc	 0x03            , 0	  ; (OP_BTFSC, REG_STATUS, STATUS_C)
          incfsz 0x23            , 0	  ; (OP_INCFSZ, multiplicand1, DEST_W)
          addwf	 0x28            , 1	  ; (OP_ADDWF, result4, DEST_F)
l_00002f: bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
          rrf	 0x28            , 1	  ; (OP_RRF, result4, DEST_F)
          rrf	 0x27            , 1	  ; (OP_RRF, result3, DEST_F)
          rrf	 0x26            , 1	  ; (OP_RRF, result2, DEST_F)
          rrf	 0x25            , 1	  ; (OP_RRF, result1, DEST_F)
          rrf	 0x24            , 1	  ; (OP_RRF, result0, DEST_F)
          decfsz 0x2E            , 1	  ; (OP_DECFSZ, counter, DEST_F)
          goto	 l_000027	 	  ; (OP_GOTO, top)
i_000037: return	 	 	  ; (OP_RETURN)
    ; DivideRoutine16
l_000038: movf	 0x23            , 0 	  ; (OP_MOVF, dividend1, DEST_W)
          xorwf	 0x27            , 0	  ; (OP_XORWF, divisor1, DEST_W)
          movwf	 0x21            	  ; (OP_MOVWF, sign)
          btfss	 0x27            , 7	  ; (OP_BTFSS, divisor1, 7)
          goto	 l_000042	 	  ; (OP_GOTO, dontNegateDivisor)
          comf	 0x26            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; divisor
          comf	 0x27            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; divisor
          incf	 0x26            , 1	  ; (OP_INCF, addr, DEST_F, name) ; divisor
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x27            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; divisor
l_000042: btfss	 0x23            , 7	  ; (OP_BTFSS, dividend1, 7)
          goto	 l_000049	 	  ; (OP_GOTO, dontNegateDividend)
          comf	 0x22            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; dividend
          comf	 0x23            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; dividend
          incf	 0x22            , 1	  ; (OP_INCF, addr, DEST_F, name) ; dividend
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x23            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; dividend
l_000049: clrf	 0x29            	  ; (OP_CLRF, remainder1)
          clrf	 0x28            	  ; (OP_CLRF, remainder0)
          bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
          movlw	 0x11             	  ; (OP_MOVLW, 16 + 1)
          movwf	 0x2E            	  ; (OP_MOVWF, counter)
l_00004e: rlf	 0x22            , 1	  ; (OP_RLF, dividend0, DEST_F)
          rlf	 0x23            , 1	  ; (OP_RLF, dividend1, DEST_F)
          decf	 0x2E            , 1	  ; (OP_DECF, counter, DEST_F)
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          goto	 l_000067	 	  ; (OP_GOTO, done)
          rlf	 0x28            , 1	  ; (OP_RLF, remainder0, DEST_F)
          rlf	 0x29            , 1	  ; (OP_RLF, remainder1, DEST_F)
          movf	 0x26            , 0 	  ; (OP_MOVF, divisor0, DEST_W)
          subwf	 0x28            , 1	  ; (OP_SUBWF, remainder0, DEST_F)
          btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          decf	 0x29            , 1	  ; (OP_DECF, remainder1, DEST_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, divisor1, DEST_W)
          subwf	 0x29            , 1	  ; (OP_SUBWF, remainder1, DEST_F)
          btfss	 0x29            , 7	  ; (OP_BTFSS, remainder1, 7)
          goto	 l_000065	 	  ; (OP_GOTO, notNegative)
          movf	 0x26            , 0 	  ; (OP_MOVF, divisor0, DEST_W)
          addwf	 0x28            , 1	  ; (OP_ADDWF, remainder0, DEST_F)
          btfsc	 0x03            , 0	  ; (OP_BTFSC, REG_STATUS, STATUS_C)
          incf	 0x29            , 1	  ; (OP_INCF, remainder1, DEST_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, divisor1, DEST_W)
          addwf	 0x29            , 1	  ; (OP_ADDWF, remainder1, DEST_F)
          bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
i_000064: goto	 l_00004e	 	  ; (OP_GOTO, loop)
l_000065: bsf	 0x03            , 0	  ; (OP_BSF, REG_STATUS, STATUS_C)
i_000066: goto	 l_00004e	 	  ; (OP_GOTO, loop)
l_000067: btfss	 0x21            , 7	  ; (OP_BTFSS, sign, 7)
          return	 	 	  ; (OP_RETURN, 0, 0)
          comf	 0x22            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; result
          comf	 0x23            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; result
          incf	 0x22            , 1	  ; (OP_INCF, addr, DEST_F, name) ; result
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x23            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; result
i_00006e: return	 	 	  ; (OP_RETURN, 0, 0)
    ; DivideRoutine24/16=24
          movf	 0x24            , 0 	  ; (OP_MOVF, dividend2, DEST_W)
          xorwf	 0x27            , 0	  ; (OP_XORWF, divisor1, DEST_W)
          movwf	 0x21            	  ; (OP_MOVWF, sign)
i_000072: bcf	 0x0A            , 3	  ;  PS(0x18,0x00) ; _v ; (addr + n, OP_BCF, REG_PCLATH, BIT3, "_v") ; 
i_000073: bcf	 0x0A            , 4	  ;  PS(0x18,0x00) ; v_ ; (addr + n, OP_BCF, REG_PCLATH, BIT4, "v_") ; 
          btfss	 0x27            , 7	  ; (OP_BTFSS, divisor1, 7)
          goto	 l_00007b	 	  ; (OP_GOTO, dontNegateDivisor)
          comf	 0x26            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; divisor
          comf	 0x27            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; divisor
          incf	 0x26            , 1	  ; (OP_INCF, addr, DEST_F, name) ; divisor
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x27            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; divisor
l_00007b: btfss	 0x24            , 7	  ; (OP_BTFSS, dividend2, 7)
          goto	 l_000085	 	  ; (OP_GOTO, dontNegateDividend)
          comf	 0x22            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; dividend
          comf	 0x23            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; dividend
          comf	 0x24            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; dividend
          incf	 0x22            , 1	  ; (OP_INCF, addr, DEST_F, name) ; dividend
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x23            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; dividend
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x24            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; dividend
l_000085: clrf	 0x29            	  ; (OP_CLRF, remainder1)
          clrf	 0x28            	  ; (OP_CLRF, remainder0)
          bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
          movlw	 0x19             	  ; (OP_MOVLW, 24 + 1)
          movwf	 0x2E            	  ; (OP_MOVWF, counter)
l_00008a: rlf	 0x22            , 1	  ; (OP_RLF, dividend0, DEST_F)
          rlf	 0x23            , 1	  ; (OP_RLF, dividend1, DEST_F)
          rlf	 0x24            , 1	  ; (OP_RLF, dividend2, DEST_F)
          decf	 0x2E            , 1	  ; (OP_DECF, counter, DEST_F)
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          goto	 l_0000a4	 	  ; (OP_GOTO, done)
          rlf	 0x28            , 1	  ; (OP_RLF, remainder0, DEST_F)
          rlf	 0x29            , 1	  ; (OP_RLF, remainder1, DEST_F)
          movf	 0x26            , 0 	  ; (OP_MOVF, divisor0, DEST_W)
          subwf	 0x28            , 1	  ; (OP_SUBWF, remainder0, DEST_F)
          btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          decf	 0x29            , 1	  ; (OP_DECF, remainder1, DEST_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, divisor1, DEST_W)
          subwf	 0x29            , 1	  ; (OP_SUBWF, remainder1, DEST_F)
          btfss	 0x29            , 7	  ; (OP_BTFSS, remainder1, 7)
          goto	 l_0000a2	 	  ; (OP_GOTO, notNegative)
          movf	 0x26            , 0 	  ; (OP_MOVF, divisor0, DEST_W)
          addwf	 0x28            , 1	  ; (OP_ADDWF, remainder0, DEST_F)
          btfsc	 0x03            , 0	  ; (OP_BTFSC, REG_STATUS, STATUS_C)
          incf	 0x29            , 1	  ; (OP_INCF, remainder1, DEST_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, divisor1, DEST_W)
          addwf	 0x29            , 1	  ; (OP_ADDWF, remainder1, DEST_F)
          bcf	 0x03            , 0	  ; (OP_BCF, REG_STATUS, STATUS_C)
i_0000a1: goto	 l_00008a	 	  ; (OP_GOTO, loop)
l_0000a2: bsf	 0x03            , 0	  ; (OP_BSF, REG_STATUS, STATUS_C)
i_0000a3: goto	 l_00008a	 	  ; (OP_GOTO, loop)
l_0000a4: btfss	 0x21            , 7	  ; (OP_BTFSS, sign, 7)
          return	 	 	  ; (OP_RETURN, 0, 0)
          comf	 0x22            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; result
          comf	 0x23            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; result
          comf	 0x24            , 1	  ; (OP_COMF, addr + i, DEST_F, name) ; result
          incf	 0x22            , 1	  ; (OP_INCF, addr, DEST_F, name) ; result
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x23            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; result
          btfsc	 0x03            , 2	  ; (OP_BTFSC, REG_STATUS, STATUS_Z)
          incf	 0x24            , 1	  ; (OP_INCF, addr + i, DEST_F, name) ; result
i_0000ae: return	 	 	  ; (OP_RETURN, 0, 0)
    ; Program Start
    ; Configure Timer1
l_0000af: clrwdt	 	 	  ; (OP_CLRWDT)
          movlw	 0x88             	  ; (REG_CCPR1L, (BYTE)(plcTmr.tmr & 0xff)) ; 0x88
          movwf	 0x15            	  ; (REG_CCPR1L, (BYTE)(plcTmr.tmr & 0xff)) ; 0x15
          movlw	 0x13             	  ; (REG_CCPR1H, (BYTE)(plcTmr.tmr >> 8)) ; 0x13
          movwf	 0x16            	  ; (REG_CCPR1H, (BYTE)(plcTmr.tmr >> 8)) ; 0x16
          movlw	 0x00             	  ; (REG_TMR1L, 0) ; 0x0
          movwf	 0x0E            	  ; (REG_TMR1L, 0) ; 0xE
          movlw	 0x00             	  ; (REG_TMR1H, 0) ; 0x0
          movwf	 0x0F            	  ; (REG_TMR1H, 0) ; 0xF
          movlw	 0x31             	  ; (REG_T1CON, plcTmr.PS) ; 0x31
          movwf	 0x10            	  ; (REG_T1CON, plcTmr.PS) ; 0x10
          movlw	 0x0B             	  ; (REG_CCP1CON, ccp1con) ; 0xB
          movwf	 0x17            	  ; (REG_CCP1CON, ccp1con) ; 0x17
    ; Now zero out the RAM
          movlw	 0x5F             	  ; (OP_MOVLW, Prog.mcu()->ram[i].len - 1)
          movwf	 0x20            	  ; (OP_MOVWF, Prog.mcu()->ram[i].start & ~BankMask())
          movlw	 0x21             	  ; (OP_MOVLW, (Prog.mcu()->ram[i].start + 1) & ~BankMask())
          movwf	 0x04            	  ; (OP_MOVWF, REG_FSR)
l_0000c0: clrf	 0x00            	  ; (OP_CLRF, REG_INDF)
          incf	 0x04            , 1	  ; (OP_INCF, REG_FSR, DEST_F)
          decfsz 0x20            , 1	  ; (OP_DECFSZ, Prog.mcu()->ram[i].start & ~BankMask(), DEST_F)
          goto	 l_0000c0	 	  ; (OP_GOTO, zeroMem)
          bsf	 0x03            , 5	  ;  BS(0x00,0x188) ; (OP_BSF, REG_STATUS, STATUS_RP0)
          bsf	 0x03            , 6	  ;  BS(0x00,0x188) ; (OP_BSF, REG_STATUS, STATUS_RP1)
    ; Set up the ANSELx registers. 1-analog input, 0-digital I/O.
          clrf	 0x08            	  ; (OP_CLRF, REG_ANSEL)
          clrf	 0x09            	  ; (OP_CLRF, REG_ANSELH)
          bcf	 0x03            , 5	  ;  BS(0x180,0x05) ; (OP_BCF, REG_STATUS, STATUS_RP0)
          bcf	 0x03            , 6	  ;  BS(0x180,0x05) ; (OP_BCF, REG_STATUS, STATUS_RP1)
    ; Set up the TRISx registers (direction). 1-tri-stated (input), 0-output and drive the outputs low to start
          movlw	 0x00             	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x0
          movwf	 0x05            	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x5
          movlw	 0x00             	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x0
          movwf	 0x06            	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x6
          movlw	 0x00             	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x0
          movwf	 0x07            	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x7
          movlw	 0x00             	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x0
          movwf	 0x08            	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x8
          movlw	 0x00             	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x0
          movwf	 0x09            	  ; (Prog.mcu()->outputRegs[i], 0x00) ; 0x9
          bsf	 0x03            , 5	  ;  BS(0x00,0x85) ; (OP_BSF, REG_STATUS, STATUS_RP0)
          movlw	 0xFF             	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0xFF
          movwf	 0x05            	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0x85
          movlw	 0xFF             	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0xFF
          movwf	 0x06            	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0x86
          movlw	 0xFA             	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0xFA
          movwf	 0x07            	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0x87
          movlw	 0xFF             	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0xFF
          movwf	 0x08            	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0x88
          movlw	 0xFB             	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0xFB
          movwf	 0x09            	  ; (Prog.mcu()->dirRegs[i], ~isOutput[i]) ; 0x89
l_0000df: bcf	 0x03            , 5	  ;  BS(0x80,0x0C) ; (OP_BCF, REG_STATUS, STATUS_RP0)
    ; Begin Of PLC Cycle
          btfsc	 0x0C            , 2	  ; (OP_BTFSC, addrSrc, bitSrc, nameSrc)
          bsf	 0x20            , 4	  ; (OP_BSF, addrDest, bitDest, nameDest) ; $Y_INTCON_T0IF
          btfss	 0x0C            , 2	  ; (OP_BTFSS, addrSrc, bitSrc, nameSrc)
          bcf	 0x20            , 4	  ; (OP_BCF, addrDest, bitDest, nameDest) ; $Y_INTCON_T0IF
l_0000e4: btfss	 0x0C            , 2	  ; (OP_BTFSS, REG_PIR1, CCP1IF)
          goto	 l_0000e4	 	  ; (OP_GOTO, PicProgWriteP - 1)
          bcf	 0x0C            , 2	  ; (OP_BCF, REG_PIR1, CCP1IF)
    ; Watchdog reset
          clrwdt	 	 	  ; (OP_CLRWDT)
    ; INIT TABLES
    ; 
    ; ======= START RUNG 1 =======
    ; INT_SET_BIT $rung_top
          bsf	 0x20            , 0	  ; (OP_BSF, addr1, bit1, a->name1) ; $rung_top
    ; start series [
    ; ELEM_READ_ADC
    ; INT_IF_BIT_SET $rung_top
          btfss	 0x20            , 0	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $rung_top
          goto	 l_00010a	 	  ; (OP_GOTO, condFalse)
    ; INT_READ_ADC
          movlw	 0x89             	  ; (REG_ADCON0, (adcs << adcsPos) | (MuxForAdcVariable(a->name1) << chsPos) | (0 << goPos) | (1 << 0)) ; 0x89
          movwf	 0x1F            	  ; (REG_ADCON0, (adcs << adcsPos) | (MuxForAdcVariable(a->name1) << chsPos) | (0 << goPos) | (1 << 0)) ; 0x1F
          bsf	 0x03            , 5	  ;  BS(0x00,0x9F) ; (OP_BSF, REG_STATUS, STATUS_RP0)
          movlw	 0x80             	  ; (REG_ADCON1, (1 << 7) | ((refs & 3) << 4)) ; 0x80
          movwf	 0x1F            	  ; (REG_ADCON1, (1 << 7) | ((refs & 3) << 4)) ; 0x9F
          bsf	 0x03            , 6	  ;  BS(0x80,0x188) ; (OP_BSF, REG_STATUS, STATUS_RP1)
          movlw	 0xFF             	  ; (REG_ANSEL, 0xff) ; 0xFF
          movwf	 0x08            	  ; (REG_ANSEL, 0xff) ; 0x188
          movlw	 0x3F             	  ; (REG_ANSELH, 0x3f) ; 0x3F
          movwf	 0x09            	  ; (REG_ANSELH, 0x3f) ; 0x189
          bcf	 0x03            , 5	  ;  BS(0x180,0x23) ; (OP_BCF, REG_STATUS, STATUS_RP0)
          bcf	 0x03            , 6	  ;  BS(0x180,0x23) ; (OP_BCF, REG_STATUS, STATUS_RP1)
          movlw	 0x1A             	  ; (OP_MOVLW, cyclesToWait)
          movwf	 0x23            	  ; (OP_MOVWF, Scratch1)
l_0000f9: decfsz 0x23            , 1	  ; (OP_DECFSZ, Scratch1, DEST_F)
          goto	 l_0000f9	 	  ; (OP_GOTO, wait)
          bsf	 0x1F            , 1	  ; (OP_BSF, REG_ADCON0, goPos)
l_0000fc: btfsc	 0x1F            , 1	  ; (OP_BTFSC, REG_ADCON0, goPos)
          goto	 l_0000fc	 	  ; (OP_GOTO, spin)
          movf	 0x1E            , 0 	  ; (OP_MOVF, REG_ADRESH, DEST_W)
          movwf	 0x34            	  ; (OP_MOVWF, addr1 + 1)
          bsf	 0x03            , 5	  ;  BS(0x00,0x9E) ; (OP_BSF, REG_STATUS, STATUS_RP0)
          movf	 0x1E            , 0 	  ; (OP_MOVF, REG_ADRESL, DEST_W)
          bcf	 0x03            , 5	  ;  BS(0x80,0x33) ; (OP_BCF, REG_STATUS, STATUS_RP0)
          movwf	 0x33            	  ; (OP_MOVWF, addr1)
          bsf	 0x03            , 5	  ;  BS(0x00,0x9F) ; (OP_BSF, REG_STATUS, STATUS_RP0)
          movlw	 0x80             	  ; (REG_ADCON1, (1 << 7) | (refs << 4)) ; 0x80
          movwf	 0x1F            	  ; (REG_ADCON1, (1 << 7) | (refs << 4)) ; 0x9F
          bsf	 0x03            , 6	  ;  BS(0x80,0x188) ; (OP_BSF, REG_STATUS, STATUS_RP1)
          clrf	 0x08            	  ; (OP_CLRF, REG_ANSEL)
          clrf	 0x09            	  ; (OP_CLRF, REG_ANSELH)
l_00010a: bcf	 0x03            , 5	  ;  BS(0x180,0x20) ; (OP_BCF, REG_STATUS, STATUS_RP0)
          bcf	 0x03            , 6	  ;  BS(0x180,0x20) ; (OP_BCF, REG_STATUS, STATUS_RP1)
    ; ] finish series
    ; 
    ; ======= START RUNG 2 =======
    ; INT_SET_BIT $rung_top
          bsf	 0x20            , 0	  ; (OP_BSF, addr1, bit1, a->name1) ; $rung_top
    ; start series [
    ; ELEM_PIECEWISE_LINEAR
    ; INT_IF_BIT_SET $rung_top
          btfss	 0x20            , 0	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $rung_top
          goto	 l_0001c6	 	  ; (OP_GOTO, condFalse)
    ; PWL 2
    ; INT_CLEAR_BIT $scratch
          bcf	 0x20            , 1	  ; (OP_BCF, addr1, bit1, a->name1) ; $scratch
    ; INT_IF_LES AAN2 381
    ; CopyRegToReg
          movf	 0x35            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x22            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x36            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x23            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0x7D             	  ; (OP_MOVLW, lNow, 0, comment) ; 381
          movwf	 0x26            	  ; (OP_MOVWF, addr + i, 0, comment) ; 381
          movlw	 0x01             	  ; (OP_MOVLW, lNow, 0, comment) ; 381
          movwf	 0x27            	  ; (OP_MOVWF, addr + i, 0, comment) ; 381
          bcf	 0x20            , 5	  ; (OP_BCF, addrO, bitO, "$overflow") ; $overflow
    ; save sign
          movf	 0x23            , 0 	  ; (OP_MOVF, b + sov - 1, DEST_W)
          xorwf	 0x27            , 0	  ; (OP_XORWF, a + sov - 1, DEST_W)
          movwf	 0x21            	  ; (OP_MOVWF, ScratchS)
    ; sub_
          movf	 0x26            , 0 	  ; (OP_MOVF, a, DEST_W)
          subwf	 0x22            , 1	  ; (OP_SUBWF, b, DEST_W_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, a + 1, DEST_W)
          btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          incfsz 0x27            , 0	  ; (OP_INCFSZ, a + 1, DEST_W)
          subwf	 0x23            , 1	  ; (OP_SUBWF, b + 1, DEST_W_F)
    ; check sign
          btfss	 0x21            , 7	  ; (OP_BTFSS, ScratchS, 7)
          goto	 l_00012a	 	  ; (OP_GOTO, notOverflow)
          movf	 0x23            , 0 	  ; (OP_MOVF, b + sov - 1, DEST_W)
          xorwf	 0x27            , 0	  ; (OP_XORWF, a + sov - 1, DEST_W)
          movwf	 0x21            	  ; (OP_MOVWF, ScratchS)
          btfsc	 0x21            , 7	  ; (OP_BTFSC, ScratchS, 7)
          goto	 l_00012a	 	  ; (OP_GOTO, notOverflow)
          bsf	 0x20            , 5	  ; (OP_BSF, addr, bit, "$overflow") ; $overflow
    ; XorBit
l_00012a: btfss	 0x20            , 5	  ; (OP_BTFSS, addrDest, bitDest)
          goto	 l_00012f	 	  ; (OP_GOTO, is0)
          btfsc	 0x23            , 7	  ; (OP_BTFSC, addrSrc, bitSrc)
          bcf	 0x20            , 5	  ; (OP_BCF, addrDest, bitDest)
i_00012e: goto	 l_000131	 	  ; (OP_GOTO, isEnd)
l_00012f: btfsc	 0x23            , 7	  ; (OP_BTFSC, addrSrc, bitSrc)
          bsf	 0x20            , 5	  ; (OP_BSF, addrDest, bitDest)
l_000131: btfsc	 0x20            , 5	  ; (OP_BTFSC, addrO, bitO)
          goto	 l_000134	 	  ; (OP_GOTO, ifThen)
i_000133: goto	 l_000135	 	  ; (OP_GOTO, ifEnd)
    ; INT_SET_BIT $scratch
l_000134: bsf	 0x20            , 1	  ; (OP_BSF, addr1, bit1, a->name1) ; $scratch
    ; INT_IF_BIT_SET $scratch
l_000135: btfss	 0x20            , 1	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $scratch
          goto	 l_00016b	 	  ; (OP_GOTO, condFalse)
    ; INT_SET_VARIABLE_SUBTRACT Temp := AAN2 - 190; ''; ''
    ; CopyRegToReg
          movf	 0x35            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x22            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x36            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x23            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0xBE             	  ; (OP_MOVLW, lNow, 0, comment) ; 190
          movwf	 0x26            	  ; (OP_MOVWF, addr + i, 0, comment) ; 190
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 190
    ; sub_
          movf	 0x26            , 0 	  ; (OP_MOVF, a, DEST_W)
          subwf	 0x22            , 1	  ; (OP_SUBWF, b, DEST_W_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, a + 1, DEST_W)
          btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          incfsz 0x27            , 0	  ; (OP_INCFSZ, a + 1, DEST_W)
          subwf	 0x23            , 1	  ; (OP_SUBWF, b + 1, DEST_W_F)
    ; CopyRegToReg
          movf	 0x22            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; addrB
          movwf	 0x37            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
          movf	 0x23            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; addrB
          movwf	 0x38            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
    ; INT_SET_VARIABLE_MULTIPLY Temp := Temp * 75
    ; CopyRegToReg
          movf	 0x37            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x24            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x38            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x25            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0x4B             	  ; (OP_MOVLW, lNow, 0, comment) ; 75
          movwf	 0x22            	  ; (OP_MOVWF, addr + i, 0, comment) ; 75
          clrf	 0x23            	  ; (OP_CLRF, addr + i, 0, comment) ; 75
          call	 l_000008	 	  ; (OP_CALL, addr, 0, comment) ; MultiplyRoutineAddress
    ; CopyRegToReg
          movf	 0x24            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch2
          movwf	 0x37            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
          movf	 0x25            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch2
          movwf	 0x38            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
    ; INT_SET_VARIABLE_DIVIDE Temp := Temp / 190
    ; CopyRegToReg
          movf	 0x37            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x22            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x38            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x23            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0xBE             	  ; (OP_MOVLW, lNow, 0, comment) ; 190
          movwf	 0x26            	  ; (OP_MOVWF, addr + i, 0, comment) ; 190
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 190
i_00015b: bcf	 0x0A            , 3	  ;  PS(0x18,0x00) ; _v ; (addr + n, OP_BCF, REG_PCLATH, BIT3, "_v") ; 
i_00015c: bcf	 0x0A            , 4	  ;  PS(0x18,0x00) ; v_ ; (addr + n, OP_BCF, REG_PCLATH, BIT4, "v_") ; 
          call	 l_000038	 	  ; (OP_CALL, addr, 0, comment) ; DivideRoutineAddress
    ; CopyRegToReg
          movf	 0x22            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch0
          movwf	 0x37            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
          movf	 0x23            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch0
          movwf	 0x38            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
    ; INT_SET_VARIABLE_ADD Temp := Temp + 75; ''; ''
    ; CopyLitToReg
          movlw	 0x4B             	  ; (OP_MOVLW, lNow, 0, comment) ; 75
          movwf	 0x26            	  ; (OP_MOVWF, addr + i, 0, comment) ; 75
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 75
    ; add
          movf	 0x26            , 0 	  ; (OP_MOVF, a, DEST_W)
          addwf	 0x37            , 1	  ; (OP_ADDWF, b, DEST_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, a + 1, DEST_W)
          btfsc	 0x03            , 0	  ; (OP_BTFSC, REG_STATUS, STATUS_C)
          incfsz 0x27            , 0	  ; (OP_INCFSZ, a + 1, DEST_W)
          addwf	 0x38            , 1	  ; (OP_ADDWF, b + 1, DEST_F)
    ; CopyRegToReg
    ; PWL 1
    ; INT_CLEAR_BIT $scratch
l_00016b: bcf	 0x20            , 1	  ; (OP_BCF, addr1, bit1, a->name1) ; $scratch
    ; INT_IF_LES AAN2 191
    ; CopyRegToReg
          movf	 0x35            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x22            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x36            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x23            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0xBF             	  ; (OP_MOVLW, lNow, 0, comment) ; 191
          movwf	 0x26            	  ; (OP_MOVWF, addr + i, 0, comment) ; 191
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 191
          bcf	 0x20            , 5	  ; (OP_BCF, addrO, bitO, "$overflow") ; $overflow
    ; save sign
          movf	 0x23            , 0 	  ; (OP_MOVF, b + sov - 1, DEST_W)
          xorwf	 0x27            , 0	  ; (OP_XORWF, a + sov - 1, DEST_W)
          movwf	 0x21            	  ; (OP_MOVWF, ScratchS)
    ; sub_
          movf	 0x26            , 0 	  ; (OP_MOVF, a, DEST_W)
          subwf	 0x22            , 1	  ; (OP_SUBWF, b, DEST_W_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, a + 1, DEST_W)
          btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          incfsz 0x27            , 0	  ; (OP_INCFSZ, a + 1, DEST_W)
          subwf	 0x23            , 1	  ; (OP_SUBWF, b + 1, DEST_W_F)
i_00017d: bcf	 0x0A            , 3	  ;  PS(0x18,0x01) ; _v ; (addr + n, OP_BCF, REG_PCLATH, BIT3, "_v") ; 
i_00017e: bcf	 0x0A            , 4	  ;  PS(0x18,0x01) ; v_ ; (addr + n, OP_BCF, REG_PCLATH, BIT4, "v_") ; 
    ; check sign
          btfss	 0x21            , 7	  ; (OP_BTFSS, ScratchS, 7)
          goto	 l_000187	 	  ; (OP_GOTO, notOverflow)
          movf	 0x23            , 0 	  ; (OP_MOVF, b + sov - 1, DEST_W)
          xorwf	 0x27            , 0	  ; (OP_XORWF, a + sov - 1, DEST_W)
          movwf	 0x21            	  ; (OP_MOVWF, ScratchS)
          btfsc	 0x21            , 7	  ; (OP_BTFSC, ScratchS, 7)
          goto	 l_000187	 	  ; (OP_GOTO, notOverflow)
          bsf	 0x20            , 5	  ; (OP_BSF, addr, bit, "$overflow") ; $overflow
    ; XorBit
l_000187: btfss	 0x20            , 5	  ; (OP_BTFSS, addrDest, bitDest)
          goto	 l_00018c	 	  ; (OP_GOTO, is0)
          btfsc	 0x23            , 7	  ; (OP_BTFSC, addrSrc, bitSrc)
          bcf	 0x20            , 5	  ; (OP_BCF, addrDest, bitDest)
i_00018b: goto	 l_00018e	 	  ; (OP_GOTO, isEnd)
l_00018c: btfsc	 0x23            , 7	  ; (OP_BTFSC, addrSrc, bitSrc)
          bsf	 0x20            , 5	  ; (OP_BSF, addrDest, bitDest)
l_00018e: btfsc	 0x20            , 5	  ; (OP_BTFSC, addrO, bitO)
          goto	 l_000191	 	  ; (OP_GOTO, ifThen)
i_000190: goto	 l_000192	 	  ; (OP_GOTO, ifEnd)
    ; INT_SET_BIT $scratch
l_000191: bsf	 0x20            , 1	  ; (OP_BSF, addr1, bit1, a->name1) ; $scratch
    ; INT_IF_BIT_SET $scratch
l_000192: btfss	 0x20            , 1	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $scratch
          goto	 l_0001c6	 	  ; (OP_GOTO, condFalse)
    ; INT_SET_VARIABLE_SUBTRACT Temp := AAN2 - 0; ''; ''
    ; CopyRegToReg
          movf	 0x35            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x22            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x36            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; AAN2
          movwf	 0x23            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          clrf	 0x26            	  ; (OP_CLRF, addr + i, 0, comment) ; 0
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 0
    ; sub_
          movf	 0x26            , 0 	  ; (OP_MOVF, a, DEST_W)
          subwf	 0x22            , 1	  ; (OP_SUBWF, b, DEST_W_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, a + 1, DEST_W)
          btfss	 0x03            , 0	  ; (OP_BTFSS, REG_STATUS, STATUS_C)
          incfsz 0x27            , 0	  ; (OP_INCFSZ, a + 1, DEST_W)
          subwf	 0x23            , 1	  ; (OP_SUBWF, b + 1, DEST_W_F)
    ; CopyRegToReg
          movf	 0x22            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; addrB
          movwf	 0x37            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
          movf	 0x23            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; addrB
          movwf	 0x38            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
    ; INT_SET_VARIABLE_MULTIPLY Temp := Temp * 75
    ; CopyRegToReg
          movf	 0x37            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x24            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x38            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x25            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0x4B             	  ; (OP_MOVLW, lNow, 0, comment) ; 75
          movwf	 0x22            	  ; (OP_MOVWF, addr + i, 0, comment) ; 75
          clrf	 0x23            	  ; (OP_CLRF, addr + i, 0, comment) ; 75
          call	 l_000008	 	  ; (OP_CALL, addr, 0, comment) ; MultiplyRoutineAddress
    ; CopyRegToReg
          movf	 0x24            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch2
          movwf	 0x37            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
          movf	 0x25            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch2
          movwf	 0x38            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
    ; INT_SET_VARIABLE_DIVIDE Temp := Temp / 190
    ; CopyRegToReg
          movf	 0x37            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x22            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
          movf	 0x38            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Temp
          movwf	 0x23            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; $CopyArgToReg
    ; CopyLitToReg
          movlw	 0xBE             	  ; (OP_MOVLW, lNow, 0, comment) ; 190
          movwf	 0x26            	  ; (OP_MOVWF, addr + i, 0, comment) ; 190
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 190
i_0001b7: bcf	 0x0A            , 3	  ;  PS(0x18,0x00) ; _v ; (addr + n, OP_BCF, REG_PCLATH, BIT3, "_v") ; 
i_0001b8: bcf	 0x0A            , 4	  ;  PS(0x18,0x00) ; v_ ; (addr + n, OP_BCF, REG_PCLATH, BIT4, "v_") ; 
          call	 l_000038	 	  ; (OP_CALL, addr, 0, comment) ; DivideRoutineAddress
    ; CopyRegToReg
          movf	 0x22            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch0
          movwf	 0x37            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
          movf	 0x23            , 0 	  ; (OP_MOVF, addr2 + i, DEST_W, name2) ; Scratch0
          movwf	 0x38            	  ; (OP_MOVWF, addr1 + i, 0, name1) ; Temp
    ; INT_SET_VARIABLE_ADD Temp := Temp + 0; ''; ''
    ; CopyLitToReg
          clrf	 0x26            	  ; (OP_CLRF, addr + i, 0, comment) ; 0
          clrf	 0x27            	  ; (OP_CLRF, addr + i, 0, comment) ; 0
    ; add
          movf	 0x26            , 0 	  ; (OP_MOVF, a, DEST_W)
          addwf	 0x37            , 1	  ; (OP_ADDWF, b, DEST_F)
          movf	 0x27            , 0 	  ; (OP_MOVF, a + 1, DEST_W)
          btfsc	 0x03            , 0	  ; (OP_BTFSC, REG_STATUS, STATUS_C)
          incfsz 0x27            , 0	  ; (OP_INCFSZ, a + 1, DEST_W)
          addwf	 0x38            , 1	  ; (OP_ADDWF, b + 1, DEST_F)
    ; CopyRegToReg
    ; ] finish series
    ; 
    ; ======= START RUNG 3 =======
    ; INT_SET_BIT $rung_top
l_0001c6: bsf	 0x20            , 0	  ; (OP_BSF, addr1, bit1, a->name1) ; $rung_top
i_0001c7: bcf	 0x0A            , 3	  ;  PS(0x18,0x01) ; _v ; (addr + n, OP_BCF, REG_PCLATH, BIT3, "_v") ; 
i_0001c8: bcf	 0x0A            , 4	  ;  PS(0x18,0x01) ; v_ ; (addr + n, OP_BCF, REG_PCLATH, BIT4, "v_") ; 
    ; start series [
    ; ELEM_CONTACTS
    ; INT_IF_BIT_CLEAR Xb3
          btfsc	 0x06            , 3	  ; (OP_BTFSC, addr1, bit1, a->name1) ; Xb3
          goto	 l_0001cc	 	  ; (OP_GOTO, condFalse)
    ; INT_CLEAR_BIT $rung_top
          bcf	 0x20            , 0	  ; (OP_BCF, addr1, bit1, a->name1) ; $rung_top
    ; start parallel [
    ; INT_COPY_BIT_TO_BIT $parThis_0:=$rung_top
l_0001cc: btfsc	 0x20            , 0	  ; (OP_BTFSC, addrSrc, bitSrc, nameSrc)
          bsf	 0x20            , 2	  ; (OP_BSF, addrDest, bitDest, nameDest)
          btfss	 0x20            , 0	  ; (OP_BTFSS, addrSrc, bitSrc, nameSrc)
          bcf	 0x20            , 2	  ; (OP_BCF, addrDest, bitDest, nameDest)
    ; ELEM_COIL
    ; INT_IF_BIT_SET $parThis_0
          btfss	 0x20            , 2	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $parThis_0
          goto	 l_0001d3	 	  ; (OP_GOTO, condFalse)
    ; INT_SET_BIT Yc0
          bsf	 0x07            , 0	  ; (OP_BSF, addr1, bit1, a->name1) ; Yc0
    ; INT_COPY_BIT_TO_BIT $parThis_0:=$rung_top
l_0001d3: btfsc	 0x20            , 0	  ; (OP_BTFSC, addrSrc, bitSrc, nameSrc)
          bsf	 0x20            , 2	  ; (OP_BSF, addrDest, bitDest, nameDest)
          btfss	 0x20            , 0	  ; (OP_BTFSS, addrSrc, bitSrc, nameSrc)
          bcf	 0x20            , 2	  ; (OP_BCF, addrDest, bitDest, nameDest)
    ; ELEM_COIL
    ; INT_IF_BIT_SET $parThis_0
          btfss	 0x20            , 2	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $parThis_0
          goto	 l_0001da	 	  ; (OP_GOTO, condFalse)
    ; INT_CLEAR_BIT Ye2
          bcf	 0x09            , 2	  ; (OP_BCF, addr1, bit1, a->name1) ; Ye2
    ; ] finish parallel
    ; ] finish series
    ; 
    ; ======= START RUNG 4 =======
    ; INT_SET_BIT $rung_top
l_0001da: bsf	 0x20            , 0	  ; (OP_BSF, addr1, bit1, a->name1) ; $rung_top
    ; start series [
    ; ELEM_CONTACTS
    ; INT_IF_BIT_CLEAR Xb0
          btfsc	 0x06            , 0	  ; (OP_BTFSC, addr1, bit1, a->name1) ; Xb0
          goto	 l_0001de	 	  ; (OP_GOTO, condFalse)
    ; INT_CLEAR_BIT $rung_top
          bcf	 0x20            , 0	  ; (OP_BCF, addr1, bit1, a->name1) ; $rung_top
    ; start parallel [
    ; INT_COPY_BIT_TO_BIT $parThis_1:=$rung_top
l_0001de: btfsc	 0x20            , 0	  ; (OP_BTFSC, addrSrc, bitSrc, nameSrc)
          bsf	 0x20            , 3	  ; (OP_BSF, addrDest, bitDest, nameDest)
          btfss	 0x20            , 0	  ; (OP_BTFSS, addrSrc, bitSrc, nameSrc)
          bcf	 0x20            , 3	  ; (OP_BCF, addrDest, bitDest, nameDest)
    ; ELEM_COIL
    ; INT_IF_BIT_SET $parThis_1
          btfss	 0x20            , 3	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $parThis_1
          goto	 l_0001e5	 	  ; (OP_GOTO, condFalse)
    ; INT_CLEAR_BIT Yc0
          bcf	 0x07            , 0	  ; (OP_BCF, addr1, bit1, a->name1) ; Yc0
    ; INT_COPY_BIT_TO_BIT $parThis_1:=$rung_top
l_0001e5: btfsc	 0x20            , 0	  ; (OP_BTFSC, addrSrc, bitSrc, nameSrc)
          bsf	 0x20            , 3	  ; (OP_BSF, addrDest, bitDest, nameDest)
          btfss	 0x20            , 0	  ; (OP_BTFSS, addrSrc, bitSrc, nameSrc)
          bcf	 0x20            , 3	  ; (OP_BCF, addrDest, bitDest, nameDest)
    ; ELEM_COIL
    ; INT_IF_BIT_SET $parThis_1
          btfss	 0x20            , 3	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $parThis_1
          goto	 l_0001ec	 	  ; (OP_GOTO, condFalse)
    ; INT_SET_BIT Ye2
          bsf	 0x09            , 2	  ; (OP_BSF, addr1, bit1, a->name1) ; Ye2
    ; ] finish parallel
    ; ] finish series
    ; 
    ; ======= START RUNG 5 =======
    ; INT_SET_BIT $rung_top
l_0001ec: bsf	 0x20            , 0	  ; (OP_BSF, addr1, bit1, a->name1) ; $rung_top
    ; start series [
    ; ELEM_CONTACTS
    ; INT_IF_BIT_CLEAR Xb1
          btfsc	 0x06            , 1	  ; (OP_BTFSC, addr1, bit1, a->name1) ; Xb1
          goto	 l_0001f0	 	  ; (OP_GOTO, condFalse)
    ; INT_CLEAR_BIT $rung_top
          bcf	 0x20            , 0	  ; (OP_BCF, addr1, bit1, a->name1) ; $rung_top
    ; ELEM_COIL
    ; INT_IF_BIT_SET $rung_top
l_0001f0: btfss	 0x20            , 0	  ; (OP_BTFSS, addr1, bit1, a->name1) ; $rung_top
          goto	 l_0001f3	 	  ; (OP_GOTO, condFalse)
    ; INT_SET_BIT Yc2
          bsf	 0x07            , 2	  ; (OP_BSF, addr1, bit1, a->name1) ; Yc2
    ; ] finish series
    ; Latest INT_OP here
    ; GOTO next PLC cycle
l_0001f3: goto	 l_0000df	 	  ; (OP_GOTO, BeginOfPLCCycle)
l_0001f4: goto	 l_0001f4	 	  ; (OP_GOTO, PicProgWriteP)
	END

;|  # | Name                                                    | Size      | Address      | Bit # |
;|Variables: 22
;|  3 | AAN0                                              	|   2 byte  | 0x0033       |
;|  5 | Temp                                              	|   2 byte  | 0x0037       |
;| 20 | AAN2                                              	|   2 byte  | 0x0035       |
;| 21 | 190                                               	|   2 byte  | 0x0039       |

;|Internal Relays: 6
;|  0 | $rung_top                                         	|   1 bit   | 0x0020       | 0     |
;|  1 | $scratch                                          	|   1 bit   | 0x0020       | 1     |
;|  2 | $parThis_0                                        	|   1 bit   | 0x0020       | 2     |
;|  3 | $parThis_1                                        	|   1 bit   | 0x0020       | 3     |
;|  4 | $Y_INTCON_T0IF                                    	|   1 bit   | 0x0020       | 4     |
;|  5 | $overflow                                         	|   1 bit   | 0x0020       | 5     |

